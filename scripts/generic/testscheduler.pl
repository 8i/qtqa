#!/usr/bin/env perl
#############################################################################
##
## Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
## Contact: http://www.qt-project.org/
##
## This file is part of the Quality Assurance module of the Qt Toolkit.
##
## $QT_BEGIN_LICENSE:LGPL$
## GNU Lesser General Public License Usage
## This file may be used under the terms of the GNU Lesser General Public
## License version 2.1 as published by the Free Software Foundation and
## appearing in the file LICENSE.LGPL included in the packaging of this
## file. Please review the following information to ensure the GNU Lesser
## General Public License version 2.1 requirements will be met:
## http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
##
## In addition, as a special exception, Nokia gives you certain additional
## rights. These rights are described in the Nokia Qt LGPL Exception
## version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
##
## GNU General Public License Usage
## Alternatively, this file may be used under the terms of the GNU General
## Public License version 3.0 as published by the Free Software Foundation
## and appearing in the file LICENSE.GPL included in the packaging of this
## file. Please review the following information to ensure the GNU General
## Public License version 3.0 requirements will be met:
## http://www.gnu.org/copyleft/gpl.html.
##
## Other Usage
## Alternatively, this file may be used in accordance with the terms and
## conditions contained in a signed written agreement between you and Nokia.
##
##
##
##
##
##
## $QT_END_LICENSE$
##
#############################################################################

use 5.010;
use strict;
use warnings;

package QtQA::App::TestScheduler;

=head1 NAME

testscheduler - run a set of autotests

=head1 SYNOPSIS

  # Run all tests mentioned in testplan.txt, up to 4 at a time
  $ ./testscheduler --plan testplan.txt -j4 --timeout 120

Run a set of testcases and output a summary of the results.

=head2 OPTIONS

=over

=item --plan FILENAME (Mandatory)

Execute the test plan from this file.
The test plan should be generated by the "testplanner" command.

=item -j N

=item --jobs N

Execute tests in parallel, up to N concurrently.

Note that only tests marked with parallel_test in the testplan
are permitted to run in parallel.

=back

All other arguments are passed to the "testrunner" script,
which is invoked once for each test.

=head1 DESCRIPTION

testscheduler runs a set of autotests from a testplan.

testscheduler implements appropriate handling of insignificant
tests and parallel tests according to the metadata in the
testplan (which generally comes from the build system):

=over

=item *

Tests may be run in parallel if they are marked with
parallel_test and testscheduler is invoked with a -j option
higher than 1.

=item *

Test failures may be ignored if a test is marked with insignificant_test.

=back

=cut

use English qw(-no_match_vars);
use File::Spec::Functions;
use FindBin;
use IO::File;
use Lingua::EN::Inflect qw(inflect);
use Pod::Usage;
use Readonly;

use Getopt::Long qw(
    GetOptionsFromArray
    :config pass_through bundling
);

# testrunner script
Readonly my $TESTRUNNER => catfile( $FindBin::Bin, 'testrunner.pl' );

sub new
{
    my ($class) = @_;

    return bless {
        jobs => 1,
    }, $class;
}

sub run
{
    my ($self, @args) = @_;

    GetOptionsFromArray( \@args,
        'help|?'    =>  sub { pod2usage(0) },
        'plan=s'    =>  \$self->{ testplan },
        'j|jobs=i'  =>  \$self->{ jobs },
    ) || pod2usage(2);

    # Strip trailing --, if that's what ended our argument processing
    if (@args && $args[0] eq '--') {
        shift @args;
    }

    # All remaining args are for testrunner
    $self->{ testrunner_args } = [ @args ];

    if (!$self->{ testplan }) {
        die "Missing mandatory --plan argument";
    }

    my @results = $self->do_testplan( $self->{ testplan } );
    $self->exit_appropriately( @results );

    return;
}

sub do_testplan
{
    my ($self, $testplan) = @_;

    my @tests = $self->read_tests_from_testplan( $testplan );
    @tests = sort { $a->{ TARGET } cmp $b->{ TARGET } } @tests;

    return $self->execute_tests_from_testplan( @tests );
}

sub read_tests_from_testplan
{
    my ($self, $testplan) = @_;

    my @tests;

    my $fh = IO::File->new( $testplan, '<' ) || die "open $testplan for read: $!";
    my $line_no = 0;
    while (my $line = <$fh>) {
        ++$line_no;
        my $test = eval $line;  ## no critic (ProhibitStringyEval)
        if (my $error = $@) {
            die "$testplan:$line_no: error: $error";
        }
        push @tests, $test;
    }

    return @tests;
}

sub execute_tests_from_testplan
{
    my ($self, @tests) = @_;

    my $jobs = $self->{ jobs };

    $self->{ test_results } = [];

    # Do all the parallel tests first, then serial.
    # However, if jobs are 1, all tests are serial.
    my @parallel_tests;
    my @serial_tests;
    foreach my $test (@tests) {
        if ($test->{ parallel_test } && $jobs > 1) {
            push @parallel_tests, $test;
        }
        else {
            push @serial_tests, $test;
        }
    }

    # If there is only one parallel test, downgrade it to a serial test
    if (@parallel_tests == 1) {
        @serial_tests = (@parallel_tests, @serial_tests);
        @parallel_tests = ();
    }

    local $SIG{ INT } = sub {
        die 'aborting due to SIGINT';
    };

    $self->execute_parallel_tests( @parallel_tests );

    if (@parallel_tests && @serial_tests) {
        my $p = scalar( @parallel_tests );
        my $s = scalar( @serial_tests );
        # NO -> Number Of
        $self->print_info( inflect "ran NO(parallel test,$p).  Starting NO(serial test,$s).\n" );
    }

    $self->execute_serial_tests( @serial_tests );

    my @test_results = @{ $self->{ test_results } };

    # Sanity check
    if (scalar(@test_results) != scalar(@tests)) {
        die 'internal error: I expected to run '.scalar(@tests).' tests, but only '
           .scalar(@test_results).' tests reported results';
    }

    return @test_results;
}

sub execute_parallel_tests
{
    my ($self, @tests) = @_;
    return unless @tests;

    while (my $test = shift @tests) {
        while ($self->running_tests_count() >= $self->{ jobs }) {
            $self->wait_for_test_to_complete( );
        }
        $self->spawn_subtest(
            test => $test,
            testrunner_args => [ '--sync-output' ],
        );
    }

    while ($self->running_tests_count()) {
        $self->wait_for_test_to_complete( );
    }

    return;
}

sub execute_serial_tests
{
    my ($self, @tests) = @_;

    return unless @tests;

    while (my $test = shift @tests) {
        while ($self->running_tests_count()) {
            $self->wait_for_test_to_complete( );
        }
        $self->spawn_subtest( test => $test );
    }

    while ($self->running_tests_count()) {
        $self->wait_for_test_to_complete( );
    }

    return;
}

sub print_info
{
    my ($self, $info) = @_;

    local $| = 1;
    print __PACKAGE__.': '.$info;

    return;
}

sub spawn_subtest
{
    my ($self, %args) = @_;

    my $test = $args{ test };

    my @testrunner_args = (
        '--chdir',
        $test->{ cwd },
        @{ $args{ testrunner_args } || []},
        @{ $self->{ testrunner_args } || []},
    );

    my @cmd_and_args = @{ $test->{ args } };

    my @testrunner_cmd = (
        $EXECUTABLE_NAME,
        $TESTRUNNER,
        @testrunner_args,
    );

    my @cmd = (@testrunner_cmd, '--', @cmd_and_args );
    my $pid = $self->spawn( @cmd );
    $self->{ test_by_pid }{ $pid } = $test;

    return;
}

sub running_tests_count
{
    my ($self) = @_;

    return scalar keys %{ $self->{ test_by_pid } || {} };
}

# Waits for one test to complete and writes the 'status' key for that test.
sub wait_for_test_to_complete
{
    my ($self) = @_;

    return if (!$self->running_tests_count( ));

    my $pid = waitpid( -1, 0 );
    my $status = $?;
    if ($pid <= 0) {
        # should never happen
        die "internal error: waitpid returned $pid (status $status)";
    }

    my $test = delete $self->{ test_by_pid }{ $pid };
    if (!$test) {
        warn "waitpid returned $pid; this pid could not be associated with any running test";
        return;
    }

    $test->{ status } = $status;

    $self->print_test_fail_info( $test );

    push @{ $self->{ test_results } }, $test;

    return;
}

sub print_test_fail_info
{
    my ($self, $test) = @_;

    if ($test->{ status } == 0) {
        return;
    }

    my $msg = "$test->{ TARGET } failed";
    if ($test->{ insignificant_test }) {
        $msg .= ', but it is marked with insignificant_test';
    }

    $self->print_info( "$msg\n" );

    return;
}

sub spawn
{
    my ($self, @cmd) = @_;

    my $pid;

    if ($OSNAME =~ m{win32}i) {
        # see `perldoc perlport'
        $pid = system( 1, @cmd );
    } else {
        $pid = fork();
        if ($pid == -1) {
            die "fork: $!";
        }
        if ($pid == 0) {
            exec( @cmd );
            die "exec: $!";
        }
    }

    return $pid;
}

sub exit_appropriately
{
    my ($self, @tests) = @_;

    my $total = 0;
    my $pass = 0;
    my $fail = 0;
    my $insignificant_fail = 0;

    foreach my $test (@tests) {
        ++$total;
        if ($test->{ status } == 0) {
            ++$pass;
        } elsif ($test->{ insignificant_test }) {
            ++$insignificant_fail;
        } else {
            ++$fail;
        }
    }

    my $message = inflect "Totals: NO(test,$total), NO(pass,$pass)";
    if ($fail) {
        $message .= inflect ", NO(fail,$fail)";
    }
    if ($insignificant_fail) {
        $message .= inflect ", NO(insignificant fail,$insignificant_fail)";
    }

    print "$message\n";

    exit( $fail ? 1 : 0 );
}

#==================================================================================================

QtQA::App::TestScheduler->new( )->run( @ARGV ) if (!caller);
1;
